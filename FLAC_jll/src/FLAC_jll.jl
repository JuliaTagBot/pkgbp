# This package autogenerated by BinaryBuilder.jl
module FLAC_jll

# We always require BP and Libdl
using BinaryProvider, Libdl
# Bring in dependencies
using Ogg_jll
# Export each product accessor (functions, strings, handles, etc...)
export libflac

# Generate underscore-prefixed variable names that map to file locations
_libflac = nothing

# Convenience function to get the current directory
moddir() = dirname(something(pathof(@__MODULE__), @__FILE__))

# Executables push their dirnames onto PATH, on all platforms
function update_exe_vars!(PATH::Vector{String} = String[])
    update_deps_exe_vars!(PATH)
    # Embed our own executable product paths
    for p in ()
        push!(PATH, dirname(p))
    end
    return unique!(PATH)
end

# Library products push their dirnames onto a variable that
# depends on the current platform, that variable name is handled
# by the calling funciton, `envvars()`
function update_lib_vars!(LIBPATH::Vector{String} = String[])
    update_deps_lib_vars!(LIBPATH)
    # Embed our own library product paths
    for p in (_libflac,)
        push!(LIBPATH, dirname(p))
    end
    return unique!(LIBPATH)
end

# Same as above, but for dependencies
function update_deps_exe_vars!(PATH::Vector{String} = String[])
        Ogg_jll.update_exe_vars!(PATH)
    return PATH
end
function update_deps_lib_vars!(LIBPATH::Vector{String} = String[])
        Ogg_jll.update_lib_vars!(LIBPATH)
    return LIBPATH
end


# Helper functions for dealing with environment variables
splitenv(l) = filter(!isempty, split(l, Sys.iswindows() ? ";" : ":"))
joinenv(l) = join(l, Sys.iswindows() ? ";" : ":")
function libpath_env()
    if Sys.iswindows()
        return "PATH"
    elseif Sys.isapple()
        return "DYLD_LIBRARY_PATH"
    else
        return "LD_LIBRARY_PATH"
    end
end

# Define the environment variables that must be set for the binaries
# to find their necessary dependencies.  We slap the dirname of every
# library product onto `LD_LIBRARY_PATH`.  We insert the dirname of
# every executable product onto `PATH`, etc...
#
# This method returns a `Dict` of environment mappings containing the
# mapping necessary for this package and all dependencies, that should
# be dynamically integrated into the current environment variables.
_envvar_cache = nothing
function envvars()
    global _envvar_cache

    # If we've already cached this work, don't do it again
    if _envvar_cache != nothing
        return _envvar_cache
    else
        _envvar_cache = Dict()
    end

    # Initialize the PATH to those paths specific to just our package
    _envvar_cache["PATH"] = update_exe_vars!()

    # For libraries, if we're on windows we merge it into PATH:
    if Sys.iswindows()
        update_lib_vars!(_envvar_cache["PATH"])
    else
        # Otherwise, it's a separate environment variable
        _envvar_cache[libpath_env()] = update_lib_vars!()
    end

    return _envvar_cache
end

# Given ENV and envvars(), merge them to create a withenv and
# apply that to `f` to run the function within an appropriate ENV
function with_merged_envs(f::Function, envs = envvars())
    merged_mapping = Pair[]
    for (k, v) in envs
        push!(merged_mapping,
            k => joinenv(vcat(splitenv(get(ENV, k, "")), v))
        )
    end

    return withenv(f, merged_mapping...)
end

function products(prefix::Prefix)
    return products = [
        LibraryProduct(prefix, ["libFLAC"], :libflac)
    ]
end

# Download and install the binaries
function build(;
        prefix::Prefix = Prefix(joinpath(moddir(), "..", "usr")),
        verbose::Bool = false,
    )
    # These are the 'location variables' that we locate() at the end
    global _libflac
    
    # Download binaries from hosted location
    bin_prefix = "https://github.com/staticfloat/FLACBuilder/releases/download/v1.3.2-2"

    download_info = Dict(
        Linux(:aarch64, libc=:glibc) => ("$bin_prefix/FLAC.v1.3.2.aarch64-linux-gnu.tar.gz", "feccdcecd2ad2d293c62cd273c33e4241c473955fd0ac2c5ccd4327414b29d2d"),
        Linux(:aarch64, libc=:musl) => ("$bin_prefix/FLAC.v1.3.2.aarch64-linux-musl.tar.gz", "8901e14c1615a0a94b987a45e721b6eea2bc5666130b4b7d51643fb3d45a3374"),
        Linux(:armv7l, libc=:glibc, call_abi=:eabihf) => ("$bin_prefix/FLAC.v1.3.2.arm-linux-gnueabihf.tar.gz", "2cd334d77592b245ea4359c3f15fd89877e179135c993a2c3c313546ba0a6f2b"),
        Linux(:armv7l, libc=:musl, call_abi=:eabihf) => ("$bin_prefix/FLAC.v1.3.2.arm-linux-musleabihf.tar.gz", "13572624c2201860e439116f637e1754da9d1e42b3c94afa8195fbefe6bd02c7"),
        Linux(:i686, libc=:glibc) => ("$bin_prefix/FLAC.v1.3.2.i686-linux-gnu.tar.gz", "8b9e05f832145ad29e1468780f525f45eaac4178e5fceedc9750ad20c0e954bc"),
        Linux(:i686, libc=:musl) => ("$bin_prefix/FLAC.v1.3.2.i686-linux-musl.tar.gz", "e90ac6049cdf2b4731c3d180404c80a3360c4c786d09cf7ca689e26a8ed3b612"),
        Windows(:i686) => ("$bin_prefix/FLAC.v1.3.2.i686-w64-mingw32.tar.gz", "0a6b8b8b37b8317afd1bbcbbfb69789b64fc62a0f7af91c26adf9ba7f22995b1"),
        Linux(:powerpc64le, libc=:glibc) => ("$bin_prefix/FLAC.v1.3.2.powerpc64le-linux-gnu.tar.gz", "5d7a7408bb6ae1e4c5761df953fd084e81634111ccce6fe06347ba6f7b522690"),
        MacOS(:x86_64) => ("$bin_prefix/FLAC.v1.3.2.x86_64-apple-darwin14.tar.gz", "f083c99d7e2089f1fe399598061c32274e13b864ff586cbe8bfcac39bcba7576"),
        Linux(:x86_64, libc=:glibc) => ("$bin_prefix/FLAC.v1.3.2.x86_64-linux-gnu.tar.gz", "b713fc92b13b08721f7b7c1316e4953e5be264c49bd1ebd4c886c9a2a64884f5"),
        Linux(:x86_64, libc=:musl) => ("$bin_prefix/FLAC.v1.3.2.x86_64-linux-musl.tar.gz", "c0827a596f073e9906cd5c3ad8e76de6a57692f5d3294931a9182d83f658ed17"),
        FreeBSD(:x86_64) => ("$bin_prefix/FLAC.v1.3.2.x86_64-unknown-freebsd11.1.tar.gz", "971d1487d19c9091c3902d920504775c167543e6c4fdfcc0702ca7026a8503f5"),
        Windows(:x86_64) => ("$bin_prefix/FLAC.v1.3.2.x86_64-w64-mingw32.tar.gz", "8d904b2c4964d3d334ebaf948cfdddef6146f4d2955b7c8578ff6c16b99774ac"),
    )

    ps = products(prefix)
    unsatisfied = any(!satisfied(p; verbose=verbose) for p in ps)

    dl_info = choose_download(download_info, platform_key_abi())
    if dl_info === nothing && unsatisfied
                # If we don't have a compatible .tar.gz to download, complain.
        # Alternatively, you could attempt to install from a separate provider,
        # build from source or something even more ambitious here.
        error("Your platform (\"$(Sys.MACHINE)\", parsed as \"$(triplet(platform_key_abi()))\") is not supported by this package!")

    end

    # If we have a download, and we are unsatisfied (or the version we're
    # trying to install is not itself installed) then load it up!
    if unsatisfied || !isinstalled(dl_info...; prefix=prefix)
        # Download and install binaries
        install(dl_info...; prefix=prefix, force=true, verbose=verbose)
    end

    # Write out a deps.jl file that will contain mappings for our products
    #depsjl_path = joinpath(moddir(), "deps.jl")
    #write_deps_file(depsjl_path, ps, verbose=verbose)

    # Actually, just locate them every time for now, using our amazing
    # prescience, knowing which index corresponds to which variable name,
    # saving ourselves the hassle of an eval(). (Eventually this could be
    # baked into a deps.jl file).  Note that we need to have our library
    # path for dependencies set properly here, otherwise we won't be able
    # to satisfy things properly.
    locate_libenv = Dict(
        libpath_env() => update_deps_lib_vars!()
    )
    if verbose
        display(locate_libenv)
    end
    with_merged_envs(locate_libenv) do
        _libflac = locate(ps[1]; verbose=verbose)
    end
end

# `libflac` is a LibraryProduct, which is exported as
# a handle that dlopen()'s 
libflac(; kwargs...) = dlopen(_libflac, RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL; kwargs...)

# Our __init__() function attempts to open `deps.jl`, then checks each
# dependency to ensure it can be satisfied.  If anything goes wrong, we
# regenerate `deps.jl` and try again.
function __init__()
    # We want other packages to be able to use us to get our metadata,
    # so provide a global turn-off switch to skip automatic install
    if get(ENV, "BINARYPROVIDER_SKIP_AUTO_INSTALL", "") == "true"
        return
    end

    # Otherwise, auto-install our products
    build()

    # Force-load all library products (for now)
    libflac()
end

end # module
